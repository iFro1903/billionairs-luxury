class BackgroundSyncManager{constructor(){this.dbName="billionairs-sync",this.dbVersion=1,this.db=null,this.init()}async init(){try{this.db=await this.openDB()}catch(e){console.error("❌ Failed to initialize Background Sync DB:",e)}}openDB(){return new Promise((e,n)=>{const t=indexedDB.open(this.dbName,this.dbVersion);t.onerror=()=>n(t.error),t.onsuccess=()=>e(t.result),t.onupgradeneeded=e=>{const n=e.target.result;if(!n.objectStoreNames.contains("pendingMessages")){const e=n.createObjectStore("pendingMessages",{keyPath:"id",autoIncrement:!0});e.createIndex("timestamp","timestamp",{unique:!1}),e.createIndex("userEmail","userEmail",{unique:!1})}if(!n.objectStoreNames.contains("pendingPayments")){const e=n.createObjectStore("pendingPayments",{keyPath:"id",autoIncrement:!0});e.createIndex("timestamp","timestamp",{unique:!1}),e.createIndex("userEmail","userEmail",{unique:!1})}if(!n.objectStoreNames.contains("pendingActions")){const e=n.createObjectStore("pendingActions",{keyPath:"id",autoIncrement:!0});e.createIndex("timestamp","timestamp",{unique:!1}),e.createIndex("type","type",{unique:!1})}}})}async savePendingMessage(e){try{this.db||await this.init();const n=this.db.transaction(["pendingMessages"],"readwrite").objectStore("pendingMessages"),t={...e,timestamp:Date.now(),synced:!1},s=await new Promise((e,s)=>{const i=n.add(t);i.onsuccess=()=>e(i.result),i.onerror=()=>s(i.error)});return await this.registerSync("sync-messages"),s}catch(e){throw console.error("❌ Failed to save pending message:",e),e}}async savePendingPayment(e){try{this.db||await this.init();const n=this.db.transaction(["pendingPayments"],"readwrite").objectStore("pendingPayments"),t={...e,timestamp:Date.now(),synced:!1},s=await new Promise((e,s)=>{const i=n.add(t);i.onsuccess=()=>e(i.result),i.onerror=()=>s(i.error)});return await this.registerSync("sync-payments"),s}catch(e){throw console.error("❌ Failed to save pending payment:",e),e}}async savePendingAction(e,n){try{this.db||await this.init();const t=this.db.transaction(["pendingActions"],"readwrite").objectStore("pendingActions"),s={type:e,data:n,timestamp:Date.now(),synced:!1},i=await new Promise((e,n)=>{const i=t.add(s);i.onsuccess=()=>e(i.result),i.onerror=()=>n(i.error)});return await this.registerSync("sync-actions"),i}catch(e){throw console.error("❌ Failed to save pending action:",e),e}}async getPendingMessages(){try{this.db||await this.init();const e=this.db.transaction(["pendingMessages"],"readonly").objectStore("pendingMessages");return await new Promise((n,t)=>{const s=e.getAll();s.onsuccess=()=>n(s.result),s.onerror=()=>t(s.error)})}catch(e){return console.error("❌ Failed to get pending messages:",e),[]}}async getPendingPayments(){try{this.db||await this.init();const e=this.db.transaction(["pendingPayments"],"readonly").objectStore("pendingPayments");return await new Promise((n,t)=>{const s=e.getAll();s.onsuccess=()=>n(s.result),s.onerror=()=>t(s.error)})}catch(e){return console.error("❌ Failed to get pending payments:",e),[]}}async getPendingActions(){try{this.db||await this.init();const e=this.db.transaction(["pendingActions"],"readonly").objectStore("pendingActions");return await new Promise((n,t)=>{const s=e.getAll();s.onsuccess=()=>n(s.result),s.onerror=()=>t(s.error)})}catch(e){return console.error("❌ Failed to get pending actions:",e),[]}}async removePendingMessage(e){try{this.db||await this.init();const n=this.db.transaction(["pendingMessages"],"readwrite").objectStore("pendingMessages");await new Promise((t,s)=>{const i=n.delete(e);i.onsuccess=()=>t(),i.onerror=()=>s(i.error)})}catch(e){console.error("❌ Failed to remove pending message:",e)}}async removePendingPayment(e){try{this.db||await this.init();const n=this.db.transaction(["pendingPayments"],"readwrite").objectStore("pendingPayments");await new Promise((t,s)=>{const i=n.delete(e);i.onsuccess=()=>t(),i.onerror=()=>s(i.error)})}catch(e){console.error("❌ Failed to remove pending payment:",e)}}async removePendingAction(e){try{this.db||await this.init();const n=this.db.transaction(["pendingActions"],"readwrite").objectStore("pendingActions");await new Promise((t,s)=>{const i=n.delete(e);i.onsuccess=()=>t(),i.onerror=()=>s(i.error)})}catch(e){console.error("❌ Failed to remove pending action:",e)}}async registerSync(e){try{if(!("serviceWorker"in navigator)||!("SyncManager"in window))return!1;const n=await navigator.serviceWorker.ready;return await n.sync.register(e),!0}catch(e){return console.error("❌ Failed to register background sync:",e),!1}}async manualSync(){let e=0;const n=await this.getPendingMessages();for(const t of n)try{(await fetch("/api/chat",{method:"POST",headers:{"Content-Type":"application/json"},body:JSON.stringify(t.data)})).ok&&(await this.removePendingMessage(t.id),e++)}catch(e){console.error("❌ Failed to sync message:",e)}const t=await this.getPendingPayments();for(const n of t)try{(await fetch("/api/payment",{method:"POST",headers:{"Content-Type":"application/json"},body:JSON.stringify(n.data)})).ok&&(await this.removePendingPayment(n.id),e++)}catch(e){console.error("❌ Failed to sync payment:",e)}const s=await this.getPendingActions();for(const n of s)try{(await fetch(`/api/${n.type}`,{method:"POST",headers:{"Content-Type":"application/json"},body:JSON.stringify(n.data)})).ok&&(await this.removePendingAction(n.id),e++)}catch(e){console.error("❌ Failed to sync action:",e)}return e}async getSyncStatus(){const e=await this.getPendingMessages(),n=await this.getPendingPayments(),t=await this.getPendingActions();return{hasPendingItems:e.length>0||n.length>0||t.length>0,pendingMessages:e.length,pendingPayments:n.length,pendingActions:t.length,totalPending:e.length+n.length+t.length}}async clearAllPending(){try{this.db||await this.init();const e=this.db.transaction(["pendingMessages","pendingPayments","pendingActions"],"readwrite");await Promise.all([new Promise((n,t)=>{const s=e.objectStore("pendingMessages").clear();s.onsuccess=()=>n(),s.onerror=()=>t(s.error)}),new Promise((n,t)=>{const s=e.objectStore("pendingPayments").clear();s.onsuccess=()=>n(),s.onerror=()=>t(s.error)}),new Promise((n,t)=>{const s=e.objectStore("pendingActions").clear();s.onsuccess=()=>n(),s.onerror=()=>t(s.error)})])}catch(e){console.error("❌ Failed to clear pending data:",e)}}}const backgroundSync=new BackgroundSyncManager;window.addEventListener("online",async()=>{const e=await backgroundSync.manualSync();e>0&&"Notification"in window&&"granted"===Notification.permission&&new Notification("BILLIONAIRS - Sync Complete",{body:`${e} items successfully synchronized`,icon:"/assets/images/icon-192x192.png"})}),window.backgroundSync=backgroundSync;